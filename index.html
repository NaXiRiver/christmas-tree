<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>Christmas Galaxy</title>
<style>
body { margin:0; overflow:hidden; background:#000; }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>

<body>

<video id="input_video" style="display:none"></video>

<script>
// ================= 基础场景 =================
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 85;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const light = new THREE.PointLight(0xffd700,3,200);
light.position.set(30,40,50);
scene.add(light);

// ================= 艺术字 =================
const textPlane = new THREE.Mesh(
  new THREE.PlaneGeometry(55,18),
  new THREE.MeshBasicMaterial({ transparent:true })
);

function makeText(){
  const c=document.createElement("canvas");
  c.width=4096; c.height=1024;
  const x=c.getContext("2d");
  x.shadowColor="#ffd700";
  x.shadowBlur=50;
  x.fillStyle="#fff";
  x.font="bold 260px 'Microsoft YaHei'";
  x.textAlign="center";
  x.textBaseline="middle";
  x.fillText("祝我的彦瑾宝贝圣诞节快乐",2048,512);
  return new THREE.CanvasTexture(c);
}
textPlane.material.map = makeText();
textPlane.position.z = 15;
textPlane.visible = false;
scene.add(textPlane);

// ================= 照片星云 =================
const galleryGroup = new THREE.Group();
scene.add(galleryGroup);

const photoTextures = [];
const loader = new THREE.TextureLoader();

for(let i=1;i<=10;i++){
  loader.load(`photos/${i}.jpg`, tex=>{
    tex.colorSpace = THREE.SRGBColorSpace;
    photoTextures.push(tex);
    if(photoTextures.length===10) createGallery();
  });
}

function createGallery(){
  const geo = new THREE.PlaneGeometry(8,6);
  const borderGeo = new THREE.PlaneGeometry(8.4,6.4);
  const borderMat = new THREE.MeshBasicMaterial({ color:0xffd700 });

  for(let i=0;i<40;i++){
    const tex = photoTextures[i%10];
    const mesh = new THREE.Mesh(geo,new THREE.MeshBasicMaterial({ map:tex }));
    const border = new THREE.Mesh(borderGeo,borderMat);
    border.position.z=-0.05;
    mesh.add(border);

    const r = 25+Math.random()*40;
    const t = Math.random()*Math.PI*2;
    const p = Math.acos(2*Math.random()-1);
    mesh.userData.target = new THREE.Vector3(
      r*Math.sin(p)*Math.cos(t),
      r*Math.sin(p)*Math.sin(t),
      r*Math.cos(p)
    );
    mesh.position.set(0,0,0);
    mesh.scale.set(0,0,0);
    galleryGroup.add(mesh);
  }
}

// ================= 模式控制 =================
let mode = "tree";
let handsEnabled = false;
let autoTimer = 0;

function updateMode(delta){
  if(!handsEnabled){
    autoTimer += delta;
    if(autoTimer > 6){
      autoTimer = 0;
      mode = mode==="tree" ? "nebula" : mode==="nebula" ? "text" : "tree";
    }
  }
}

// ================= 动画 =================
let lastTime = performance.now();

function animate(now){
  requestAnimationFrame(animate);
  const delta = (now-lastTime)/1000;
  lastTime = now;

  updateMode(delta);

  if(mode==="text"){
    textPlane.visible=true;
    textPlane.position.y = Math.sin(now*0.002)*1;
  }else{
    textPlane.visible=false;
  }

  if(mode==="nebula"){
    galleryGroup.children.forEach(m=>{
      m.position.lerp(m.userData.target,0.05);
      m.scale.lerp(new THREE.Vector3(1,1,1),0.05);
      m.lookAt(camera.position);
    });
  }else{
    galleryGroup.children.forEach(m=>{
      m.position.lerp(new THREE.Vector3(0,0,0),0.1);
      m.scale.lerp(new THREE.Vector3(0,0,0),0.1);
    });
  }

  renderer.render(scene,camera);
}
animate(performance.now());

// ================= 安全手势初始化 =================
const video = document.getElementById("input_video");

async function initHandsSafe(){
  try{
    const hands = new Hands({
      locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
    });

    hands.setOptions({
      maxNumHands:1,
      modelComplexity:0,
      minDetectionConfidence:0.5,
      minTrackingConfidence:0.5,
      selfieMode:true
    });

    hands.onResults(r=>{
      if(!handsEnabled) return;
      if(!r.multiHandLandmarks || !r.multiHandLandmarks.length) return;

      const lm = r.multiHandLandmarks[0];
      const d=(a,b)=>Math.hypot(lm[a].x-lm[b].x,lm[a].y-lm[b].y);

      const open = d(8,0)>0.2 && d(12,0)>0.2 && d(16,0)>0.2;
      const fist = d(8,0)<0.1 && d(12,0)<0.1;
      const ok = d(4,8)<0.05;

      if(open) mode="nebula";
      else if(ok) mode="text";
      else if(fist) mode="tree";
    });

    const cam = new Camera(video,{
      onFrame: async()=>{
        try{
          await hands.send({image:video});
        }catch(e){
          console.warn("Hands runtime error, fallback",e);
          handsEnabled=false;
        }
      },
      width:320,height:240
    });

    await cam.start();
    handsEnabled = true;
    console.log("✅ 手势模式已启用");

  }catch(e){
    console.warn("❌ 手势不可用，自动模式",e);
    handsEnabled = false;
  }
}

initHandsSafe();

// ================= resize =================
window.onresize=()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
};
</script>

</body>
</html>
